<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title> : DexterJS</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="../assets_/css/shCore.css">
        <link rel="stylesheet" href="../assets_/css/shThemeDefault.css">
        <link rel="stylesheet" href="../assets_/css/main.css">
    </head>
    <body data-root-path="../">
        <div id="wrapper">
            <div id="content">

<ul id="topnav">
    <li><a href="../index.html">Index</a></li>
    <li><a href="#toc">TOC</a></li>
</ul>
<h2>Table of Contents <a href="#toc" name="toc" class="deep-link">#</a></h2>

<ul>
<li><a href="#Dexter.fake">Dexter.fake()</a></li>
</ul>

<h2>Dexter.fake() <a href="#Dexter.fake" id="Dexter.fake" class="deep-link">#</a></h2>

<p>Let's suppose you already tested a <code>function foo()</code> but you still need to test a new function called <code>bar()</code>, you really doesn't need all the work behind <code>foo()</code>. </p>

<p>Dexter.fake will prevent any original functionality of a function, replacing it to a fake and non brainy call. It's like mocks and stubs.</p>

<p>Considering the global scope is a <code>window</code> object from a browser and foo is a global function, we can just do fake calls to <code>foo()</code>:</p>

<pre class="brush:javascript">

function bar() {
    var x = foo();
    return x * 2;
}

/*** in your tests: ***/

test( 'bar()', function() {
    var fake  = Dexter.fake( window, 'foo', function() {
                    return 10;
                }),
        returnedValue;

    returnedValue = bar();

    // as you set foo() to always return 10, you now can define 
    // a more precise value returned by bar()
    equal( returnedValue, 20, 'bar() => 20' );

    // fake objects also has called property
    equal( fake.called, 1, 'foo() called once' );

    // restoring foo() 
    fake.restore();

    expect( 2 );  
});
</pre>

<p>Setting callback is very like Dexter.spy, the difference is in the returned value that won't affect spied methods. You can also set or replace the callback function by the <code>fake.callback</code> property.</p>

<p>By faking with Dexter you can also verify call <code>arguments</code> and the <code>this</code> object:</p>

<pre class="brush:javascript">

function bar() {
    var dummy = {
            'Dexter' : 'JS'
        },
        x = foo.call( dummy, 7 );
    return x * 2;
}

/*** in your tests: ***/

test( 'bar()', function() {
    var fake = Dexter.fake( window, 'foo' ),
        returnedValue;

    fake.callback =  function( arg1 ) {
        var expectedThis = {
            'Dexter' : 'JS'
        };

        equal( arg1, 7, 'arguments[0] === 7' );
        deepEqual( this, expectedThis, 'this === { "Dexter" : "JS" }' );

        return arg1;
    };

    returnedValue = bar();

    equal( returnedValue, 14, 'bar() => 14' );

    equal( fake.called, 1, 'foo() called once' );

    fake.restore();

    expect( 4 );  
});
</pre>
                <hr />
                <small>Documentation generated by <a href="https://github.com/millermedeiros/mdoc">mdoc</a>.</small>
            </div>
        </div>
        <script src="../assets_/js/lib/jquery.js"></script>
        <script src="../assets_/js/lib/syntax-highlighter/shCore.js"></script>
        <script src="../assets_/js/lib/syntax-highlighter/shAutoloader.js"></script>
        <script src="../assets_/js/main.js"></script>
    </body>
</html>

